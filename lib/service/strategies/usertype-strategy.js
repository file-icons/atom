"use strict";function _createForOfIteratorHelperLoose(o){var i=0;if("undefined"==typeof Symbol||null==o[Symbol.iterator]){if(Array.isArray(o)||(o=_unsupportedIterableToArray(o)))return function(){return i>=o.length?{done:true}:{done:false,value:o[i++]}};throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}return i=o[Symbol.iterator](),i.next.bind(i)}function _unsupportedIterableToArray(o,minLen){if(o){if("string"==typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(n):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray(o,minLen):void 0}}function _arrayLikeToArray(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=Array(len);i<len;i++)arr2[i]=arr[i];return arr2}const path=require("path"),{CompositeDisposable}=require("atom"),{escapeRegExp}=require("../../utils.js"),IconTables=require("../../icons/icon-tables.js"),Strategy=require("../strategy.js");class UsertypeStrategy extends Strategy{constructor(){super({name:"usertypes",priority:3,matchesFiles:true,matchesDirs:false,ignoreVirtual:false}),this.configDisposable=null,this.customTypes=null,this.customTypeIcons=null,this.hasCustomTypes=false}enable(){if(!this.enabled&&!this.configDisposable){this.customTypes=new Map,this.customTypeIcons=new Map,this.hasCustomTypes=false,this.configDisposable=new CompositeDisposable(atom.config.onDidChange("core.customFileTypes",types=>{this.updateCustomTypes(types.newValue),this.checkAll(false)}));const types=atom.config.get("core.customFileTypes");this.updateCustomTypes(types)}return super.enable()}disable(){return this.enabled&&this.configDisposable&&(this.configDisposable.dispose(),this.configDisposable=null,this.customTypes=null,this.customTypeIcons=null,this.hasCustomTypes=false),super.disable()}matchIcon(resource){if(!this.hasCustomTypes)return null;for(var _step,_iterator=_createForOfIteratorHelperLoose(this.customTypes);!(_step=_iterator()).done;){const[scopeName,patterns]=_step.value,{names,paths}=patterns;if(null!==names&&names.test(resource.name)||null!==paths&&paths.test(resource.path))return this.customTypeIcons.get(scopeName)}return null}updateCustomTypes(types){for(const scopeName in this.customTypes.clear(),this.customTypeIcons.clear(),types){const icon=IconTables.matchScope(scopeName);if(!icon)continue;// Skip types without icons
this.customTypeIcons.set(scopeName,icon);const names=[],paths=[],patterns=types[scopeName];for(var _step2,_iterator2=_createForOfIteratorHelperLoose(patterns);!(_step2=_iterator2()).done;){const pattern=_step2.value;-1===pattern.indexOf(path.sep)?names.push(pattern):paths.push(pattern)}this.customTypes.set(scopeName,{names:this.makeNamePattern(names),paths:this.makePathPattern(paths)})}this.hasCustomTypes=!!this.customTypes.size}/**
	 * Compile an expression to match one or more file extensions.
	 *
	 * @param {String[]} names
	 * @return {RegExp|null}
	 * @private
	 */makeNamePattern(names){const{length}=names;return length?(names=names.map(s=>escapeRegExp(s.replace(/^\./,""))).join("|"),1<length&&(names=`(?:${names})`),new RegExp("(?:^|\\.)"+names+"$","i")):null}/**
	 * Compile an expression to match one or more pathnames.
	 *
	 * @param {String[]} paths
	 * @return {RegExp|null}
	 * @private
	 */makePathPattern(paths){const{length}=paths;return length?(paths=paths.map(s=>escapeRegExp(s)).join("|"),1<length&&(paths=`(?:${paths})`),new RegExp("(?:^|[\\/\\\\])"+paths+"$","i")):null}}module.exports=new UsertypeStrategy;