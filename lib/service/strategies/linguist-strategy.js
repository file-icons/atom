"use strict";function _createForOfIteratorHelperLoose(o){var i=0;if("undefined"==typeof Symbol||null==o[Symbol.iterator]){if(Array.isArray(o)||(o=_unsupportedIterableToArray(o)))return function(){return i>=o.length?{done:true}:{done:false,value:o[i++]}};throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}return i=o[Symbol.iterator](),i.next.bind(i)}function _unsupportedIterableToArray(o,minLen){if(o){if("string"==typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(n):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray(o,minLen):void 0}}function _arrayLikeToArray(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=Array(len);i<len;i++)arr2[i]=arr[i];return arr2}const path=require("path"),{Disposable}=require("atom"),IconTables=require("../../icons/icon-tables.js"),Strategy=require("../strategy.js");class LinguistStrategy extends Strategy{constructor(){super({name:"linguist",priority:4,matchesFiles:true,matchesDirs:false,ignoreVirtual:false}),this.hasRules=false,this.rules=null,this.sources=null,this.languageIcons=null}enable(){return this.enabled||(this.hasRules=false,this.rules=new Map,this.sources=new Map,this.languageIcons=new Map),super.enable()}disable(){return!!this.enabled&&(super.disable(),this.rules.clear(),this.sources.clear(),this.languageIcons.clear(),this.hasRules=false,this.rules=null,this.sources=null,this.languageIcons=null,true)}matchIcon(resource){if(!this.hasRules)return null;for(var _step,_iterator=_createForOfIteratorHelperLoose(this.rules);!(_step=_iterator()).done;){const[pattern,icon]=_step.value;if(pattern.test(resource.path))return icon}return null}registerResource(file){const isNew=super.registerResource(file);if(isNew&&!file.unreadable&&/^\.gitattributes$/.test(file.name)){this.sources.set(file,new Map);const disposables=this.resourceEvents.get(file);disposables.add(new Disposable(()=>file.unwatchSystem()),file.onDidMove(()=>this.updateSource(file)),file.onDidChangeData(()=>this.updateSource(file)),file.onDidChangeOnDisk(()=>{try{file.loadData(true)}catch(e){disposables.dispose()}})),file.watchSystem(),file.isDataComplete||file.isOpenInEditor?this.updateSource(file):file.loadData(true)}else return isNew}updateSource(file){const sourceRules=this.sources.get(file),parsedRules=new Map(this.parseSource(file.data,file.path)),updatePaths=new Set;// Deleted rules
for(var _step2,_iterator2=_createForOfIteratorHelperLoose(sourceRules);!(_step2=_iterator2()).done;){const[pattern]=_step2.value;parsedRules.has(pattern)||(updatePaths.add(pattern),sourceRules.delete(pattern),this.rules.delete(pattern))}// Added/changed rules
for(var _step3,_iterator3=_createForOfIteratorHelperLoose(parsedRules);!(_step3=_iterator3()).done;){const[pattern,icon]=_step3.value;sourceRules.get(pattern)!==icon&&(this.rules.set(pattern,icon),sourceRules.set(pattern,icon),updatePaths.add(pattern))}this.hasRules=!!this.rules.size;for(var _step4,_iterator4=_createForOfIteratorHelperLoose(updatePaths);!(_step4=_iterator4()).done;){const path=_step4.value;this.updatePath(path)}}updatePath(path){for(var _step5,_iterator5=_createForOfIteratorHelperLoose(this.resources);!(_step5=_iterator5()).done;){const[resource]=_step5.value;if(path.test(resource.path)){this.deleteIcon(resource);const icon=this.rules.get(path)||null;null!==icon&&this.addIcon(resource,icon)}}}parseSource(fileData,filePath){return fileData?fileData.replace(/^[\t ]*#.*$|^[ \t]+|[ \t]+$/gm,"").split(/(?:\r?\n)+/g).filter(s=>/\S+[ \t]+linguist-language=\w+/.test(s)).map(line=>{let[pattern,language]=line.split(/\s+linguist-language=/);// Look for this language's icon if we've not already done so.
this.languageIcons.has(language)||this.languageIcons.set(language,IconTables.matchLanguage(language));const languageIcon=this.languageIcons.get(language);// Only acknowledge languages with icons
if(!languageIcon)return null;// Lazily require the micromatch dependency due to its weight.
const Micromatch=require("micromatch");return pattern=path.dirname(filePath)+"/"+(/^\//.test(pattern)?"":"**")+"/"+pattern,pattern=path.resolve(pattern),"win32"===process.platform&&(pattern=pattern.replace(/\\/g,"/")),pattern=Micromatch.makeRe(pattern,{unixify:false,nonegate:true,dot:true}),pattern?[pattern,languageIcon]:null}).filter(a=>a):[]}}module.exports=new LinguistStrategy;